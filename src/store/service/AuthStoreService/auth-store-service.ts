import RootStore from "../../RootStore";import {LoadingEnum} from "../../types/types";import {DataPatientType} from "../../AuthStore/auth-store";import AsyncStorage from "@react-native-async-storage/async-storage";import {routerConstants} from "../../../constants/routerConstants";import {DataSignUpType, LoginPayloadType, RoomType, UploadScope, UserType} from "../../../api/type";import {DataJoinRoomType} from "../../SocketStore/type";import messaging from "@react-native-firebase/messaging";export class AuthStoreService {    rootStore: typeof RootStore;    async login(payload: LoginPayloadType): Promise<UserType | void> {        this.rootStore.Notification.setIsLoading(LoadingEnum.fetching);        try {            const data = await this.rootStore.AuthStore.login(payload);            this.rootStore.SocketStore.setUser(data)            return data        } catch (e) {            console.log(e)            this.rootStore.Notification.setNotification('error', true, 'Ошибка, введены не правильные данные');        } finally {            this.rootStore.Notification.setIsLoading(LoadingEnum.success);        }    }    async getUser(): Promise<void> {        this.rootStore.Notification.setIsLoading(LoadingEnum.fetching);        try {            const token = await AsyncStorage.getItem('token');            if (token) {                const userData = await this.rootStore.AuthStore.getUser();                await this.rootStore.AuthStore.getAppVersion()                this.rootStore.SocketStore.setUser(userData)                const currentNotification = await  messaging().getInitialNotification()                if(!!currentNotification && userData.role === 'volunteer') {                    this.rootStore.SocketStore.navigation(routerConstants.VOLUNTEER_PROFILE)                }                await this.rootStore.SocketStore.checkActiveSession()            }        } catch (e) {            console.log(e)        } finally {            this.rootStore.Notification.setIsLoading(LoadingEnum.success);        }    }    async register(userData: DataSignUpType): Promise<DataSignUpType | void> {        this.rootStore.Notification.setIsLoading(LoadingEnum.fetching);        try {            return await this.rootStore.AuthStore.register(userData);        } catch (e) {            this.rootStore.Notification.setNotification('error', true, 'Incorrect data has been entered');        } finally {            this.rootStore.Notification.setIsLoading(LoadingEnum.success);        }    }    async forgotPassword(email: string): Promise<void> {        this.rootStore.Notification.setIsLoading(LoadingEnum.fetching);        try {            await this.rootStore.AuthStore.forgotPassword(email);            this.rootStore.Notification.setNotification('success', true, 'Сheck your e-mail');        } catch (e) {            this.rootStore.Notification.setNotification('error', true, 'Incorrect data has been entered');        } finally {            this.rootStore.Notification.setIsLoading(LoadingEnum.success);        }    }    async createRoom(dataPatient: DataPatientType): Promise<RoomType | void> {        this.rootStore.Notification.setIsLoading(LoadingEnum.fetching);        try {            return await this.rootStore.SocketStore.createRoom(dataPatient);        } catch (e) {            console.log(e, 'createRoom')        } finally {            this.rootStore.Notification.setIsLoading(LoadingEnum.success);        }    }    async findRooms(): Promise<void> {        try {            await this.rootStore.AuthStore.findRooms();        } catch (e) {        } finally {        }    }    async sendUserPhoto(photo: string, scope: UploadScope, isUpdateUser = true) {        try {            const data = await this.rootStore.AuthStore.sendUserPhoto(photo, scope);            if(isUpdateUser) {                const dataUser = await this.rootStore.AuthStore.changeUser(data.path)                this.rootStore.SocketStore.setUser(dataUser)                this.rootStore.AuthStore.setUser(dataUser)            }            return data        } catch (e) {            console.log(e, 'upload')        } finally {        }    }    async logOut(): Promise<void> {        this.rootStore.Notification.setIsLoading(LoadingEnum.fetching);        try {            this.rootStore.SocketStore.clearData();            await this.rootStore.AuthStore.logout()        } catch (e) {        } finally {            this.rootStore.Notification.setIsLoading(LoadingEnum.success);        }    }    async joinRoom(idRoom): Promise<RoomType> {        this.rootStore.Notification.setIsLoading(LoadingEnum.fetching);        try {            return await this.rootStore.SocketStore.joinRoom(idRoom);        } catch (e) {            console.log(e, 'joinRoom')        } finally {            this.rootStore.Notification.setIsLoading(LoadingEnum.success);        }    }    async getDonePatients(): Promise<{ total: number } | void> {        this.rootStore.Notification.setIsLoading(LoadingEnum.fetching);        try {            return await this.rootStore.AuthStore.getDonePatients();        } catch (e) {        } finally {            this.rootStore.Notification.setIsLoading(LoadingEnum.success);        }    }    constructor(rootStore: typeof RootStore) {        this.rootStore = rootStore;    }}export default AuthStoreService;